# 计算机科学速成课

## 1计算机早期历史

![image-20210702154140999](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702154140999.png)

计算设备：键盘，美索不达米亚，十进制

星盘：航行

钟表

Conputer 计算者

步进计算机，1694，齿轮，第一台机器可以搞-+*/

计算表：写在纸上的，射程表，二战用

charles babage 差分机，多项式（多个变量的关系），失败（计算机之父）

Charles babbage 分析机，通用计算机，有内存，打印机，失败

Ada lovelace 给分析机写假想程序（第一位程序员）

1890美国人口普查，  找hereman hollerith，发明打孔卡片制表机（电动），用卡数数

他成立了国际商业计算机公司IBM international business machines corporartion

## 2电子计算机

![image-20210702154457975](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702154457975.png)

20世纪初，计算设备针对特定用途，全球化，机器发展

- 最大计算机之一 哈佛马克一号 harvard mark 1，给同盟国1944，服务曼哈顿计划

继电器：控制电路开关（大脑），控制电子（电磁原理），但是无法快速控制开关，齿轮会磨损

因为总是进虫子，影响运行，所以说bug

- 1904 John ambrose fleming 热电子管，两个电极一个玻璃灯泡（世界第一个真空管），加热一个电极，发射电子（热电子发射）；另一个电极吸引电子，形成电流（只有带正电荷的时候）

电流只能单向流动的电子部件是 二极管

1906，lee de forest在热电子管的两个电极之间加入了 控制电极（是正电极还是负电极）

标志计算机从机电转向电子

- 第一个大规模使用真空管的计算机是 colossus mk 1巨人一号，1943 tommy flowers,来破解纳粹通信

被认为第一个可编程的电子计算机

编程：把电线插入插板

电子数值积分计算机 ENIAC，1946，宾夕法尼亚大学， john mauchly j.presper eckert，第一个真正的通用，可编程的电子计算机

- 成本大小，速度可靠性

1974贝尔实验室，晶体管（计算机新时代），用半导体控制电极（有时导电，有时不导电）

1957IBM 608，第一个完全用晶体管的计算机

晶体管，半导体开发在 santa clara valley，用硅，所以才叫硅谷 Silicon Valley ，英特尔 intel，世界最大计算机芯片制造商

## 3布尔逻辑和逻辑门

![image-20210702173821423](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702173821423.png)

- 开关：二进制，真假，让不让电流通过问题

状态越多，越难分辨哪个是自己的（减少其他干扰）

数学一个成熟的体系处理真假，布尔代数只有两个值 真假，变量的值只有对错，可以进行逻辑操作 not and or

 控制线，输入；电极，输出

- 两个晶体管：2个输入和1个输出   and

or需要并联的连接方式 

- ![image-20210702172836210](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702172836210.png)
- 逻辑门：gate，控制电流对路径 not and or，可以判断布尔语句

![image-20210702173741921](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702173741921.png)

## 4二进制

![image-20210702173856253](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702173856253.png)

- 二进制表达数字 ，每两个数位相差2，数位bit

- 计算机里大部分操作都是8位8位进行处理的（256个不同的值）

8位：字节byte

1 bytes=8bits

千字节kilobyte，mega百万字节MB,giga十亿字节GB，1TB，8万亿个1和0

- 一千字节=2的10次方=1024字节

- 32位，64位计算机：一块一块处理数据，每块32位或64位

- 显示负数：用第一个数位来表示正负

- 计算机给内存的每一个位置做标记（地址），来储存数据

- 浮点数：小数点可以在数字之间浮动

常见标准IEEE 754标准：用科学计数法，存储10进制值

第一个数位存正负，之后8个数位存科学计数法的次方 ，23存储有效数字（32位计算机）

- 表示字母，标点等等：ASC||，美国信息交换标准代码the american standard code for infomation interchange，7位代码

- 换行符：打字机换行，不然无限在一行中打出看不见的字

- 统一文字：unicode：统一所有编码的标准，16位

## 5算术逻辑单元

![image-20210702225203446](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210702225203446.png)

- 算数的操作由算术逻辑单元处理ALU，负责运算的组件

intel 74181，1970，第一个封装在单个芯片内的完整ALU

- ALU有2个单元，算数单元arithmetic，逻辑单元logic

- 算数单元：输入两位，输出：用XOR  

由逻辑门组成的1+1（2个数相加）以内的运算是半加器half adder（XOR，AND逻辑门），将其封装成一个单独的组件

全加器：超过1+1（大于两个数相加）的运算：由半加器和逻辑门组成

1个半加器加上7个全加器算8位数的加法：8位行波进位加法器，如果结果进位超过8位，叫溢出（容易出现bug）

8位最大表示225

超前进进位加法器， 算得更快

- ALU算数单元还可以进行加法以外的数字运算（乘法除法用加减算）

到后面有专门做乘法的算数单元

- 逻辑单元：可以检查输出否是多少，也用逻辑门

- 8位ALU：输入 两个数字都是八位（用四位表示命令），输出 一个八位数字，和一堆标志flag（1位，表示特定状态，包括溢出标志，零测试电路，是否有0，-----两个数是否相等；负数标志-----比两个数大小）

## 6寄存器和内存

![image-20210703113100363](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703113100363.png)

- 存下来ALU计算结果
- 随机存取存储器 RAM random access memory，只有插电的时候运行
- 持久存储 persistent momory，关闭电源仍然存在
- 回向电路，输出输入相连，AND存储0，OR存储1，联系在一起是AND-OR latch（锁存器）

有两个输入：设置输入，把输出变为1

复位输入，把输出变成0

如果两个都是0，电路输出最后放入的内容，记住一位数 ，即锁存latch，锁定一个值

- 希望只有一条输入线 ，还有一根线相当于之前的复位输入，启用时允许写入，不然就是锁定，即允许写入线

做成门锁gated latch，把门锁封装，可以储存一个位数

- 一组锁存器是寄存器，寄存器存储一个数字，这个数字有多少位，就是位宽是多少

现在64位宽寄存器

所有锁存器可以用一写入根线

这样线太多了

解决方法，矩阵（通常256位的内存），把锁存器排列表格状态，行线列线是1，就可以控制特定的锁存器

行和列就是地址，把地址转换成行列，需要多路复用器multiplexer，一个处理行，一个处理列，给行列编码

- 兆字节MB，千兆字节GB

- 8位最多256个内存地址

- 随机存取存储器random access memory RAM（内存多大）：可以访问任何位置

记忆当前干的事

上面有8个内存模块（1千兆mb)，每个内存模块32个内存方块，每个方块有四个小块，每个小块事一个128*64位的矩阵

## 中央处理器 cpu

![image-20210703125923401](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703125923401.png)

- 是计算机心脏
- CPU执行程序

操作 instruction,

- 1个寄存器追踪程序运行到哪里，指令地址寄存器

1个寄存器存当前指令，指令寄存器

- 阶段：1、取指令，指令地址寄存器从RAM把指令交给 指令寄存器

2、解码，指令标号指定是什么，控制单元进行解码

3、执行，把RAM对应地址的值，放到CPU四个寄存器的一个里

- 把以上视为控制单元，控制单元也需要寄存器暂时保存结果。
- 时钟按照时间间隔，触发电信号，进行上面的三个工作的速度是时钟速度fatch-decode-execute cycle 是clock speed

单位赫兹（频率单位），1赫兹，1秒一个周期 

-  计算机超频，修改时钟速度。超频太多会过热，信号跟不上时钟

降频，减速CPU，在不太需要的时候可以省电

为了省电，有的可以自动调频，动态调整频率

![image-20210703164742102](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703164742102.png)

- CPU和RAM连接：地址线，数据线，允许读写线

## 8指令和程序

![image-20210703165117173](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703165117173.png)

- 因为CPU可编程，所以强大。CPU是硬件，可以被软件控制

- RAM的每个地址可以存8位数据，前四位表示操作，后四位指定内存地址（寄存器），可惜太少了，解决方式：用更多的位来表示指令（指令长度）；可变指定长度，立即值，操作后面加上位置值

- 指令和数据都是存在同一个内存里

- 无限循环infinite loop，需要有条件的jump

- ALU没有除法，程序可以给它

- 1971英特尔4004处理器，第一次把CPU做成一个芯片

## 9高级CPU设计

![image-20210703180359577](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703180359577.png)

- 计算机提速方式：减少晶体管的切换时间；直接在硬件层面设计除法；

快速将数据传给CPU：CPU与RAM用总线相连（BUS），过程中会有延迟。

解决延迟的方法：在CPU里加一点RAM（缓存）：所需数据在缓存里面（缓存命中cache hit);不在是缓存未命中(cache miss)

- 有时缓存和RAM不一致：所以缓存里每个空间有一个特殊标记，脏位dirty bit；

两者同步时间：缓存满了但是需要新的缓存，会把脏位进行同步

- 指令流水线：并行处理，三个周期同时在处理不同指令

问题：指令之间的依赖关系，如果指令有矛盾，需要及时停止

高级CUP会进一步动态排序指令，避免矛盾，即乱序执行out-of-order execution

- 条件跳转 ，高级CPU推测执行的指令，放到流水线，即推测执行speculative execution。如果预测失败，需要清空流水线。

为了提升预测的可能性，加强分支预测branch prediction

- 超标量处理器：一个时钟周期处理多个指令，如果多条指令要CPU的不同部分，就要同时处理
- 同时运行多个指令流，多核处理器multi-core processors，有多个独立处理单元；甚至需要多个CPU
- 超级计算机supercomputer：神威太湖之光有40960个CPU，每个有256个核心。
- 每秒浮点运算次数flops
- 复杂度和速度的平衡 

## 10早期的编程方式

![image-20210703202224875](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703202224875.png)

- 指令的执行，计算机程序

- 1801可编程纺织机，穿孔纸卡

- 为了执行不同运算，需要控制面板 control panel=插线板plug boards，通过插孔，使机器不同部分互相传数据和信号。运行不同程序需要重新接线

1946，世界上第一台通用电子计算机ENIAC

- 将程序存在内存里，存储程序计算机stored-program computer

程序和数据都存在“冯诺伊曼结构”von neumann architecture

冯诺伊曼计算机：1个处理器（算术逻辑单元，数据寄存器，指令寄存器，指令地址寄存器）+内存（RAM）

第一台冯诺伊曼架构的储存程序计算机1948，baby

- 通过穿孔纸卡写程序punch card进入内存，穿孔纸卡也可以取出数据

- 纸带，连续的穿孔纸卡

1980以前，面板编程（用各种开关按钮编程）

1975家用计算机

## 11编程语言发展史

![image-20210703210517987](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703210517987.png)

- 二进制，机器语言，机器码
- 对程序进行人类语言的描述：伪代码pseudo-code

用操作码表把伪代码转化为二进制

- 为了人类更可读，：给每个操作码名字，助记符mnemonics，后面跟数据：即汇编指令

写二进制程序进行转化，来转化文字指令（汇编语言assembly language)到二进制命令，汇编器assembler

- 自动分析jump地址（不需要在改了上边的还要再一个个写跳转地址），等等，使程序员可以专心编程，不管底层细节

- 算数语言版本0 arithmetic language version 0 A-0，高级编程语言可以转化多条二进制指令。1952，第一个编译器：把高级语言转化成低级语言（编译器会给你搞定底层细节）

公式翻译fortran，1957 

1959，数据系统语言委员会committee on data systems languages，开发通用编程语言在不同机器使用 ，普通面向商业语言COBOL，一次编写，到处运行（降低门槛）

70S：C

80S：c++，objective C

90S：python，ruby，java

00S：swift，C#，go

- 变量variables：代表内存地址的抽象

## 12编程基础，语句和函数

![image-20210703214548721](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210703214548721.png)

- 语句statement ，规定语句的规则语法syntax

赋值语句assignment statement

- 初始化initialize：设置最开始的值

- 控制流语句flow statement（比如if)：表达式是真是假，这些表达式即“条件语句”conditional statements

- 把代码打包，直接使用，函数functions/方法mathods/子程序subroutines，用的时候写个名字就行

return语句，指明返回内容

函数可以套函数

- 模块化编程
- 现代化编程语言，许多预先写好的函数集合，库libraries

## 13算法入门

![image-20210704163959065](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704163959065.png)

- 算法algorithm：解决问题的具体步骤：步骤越少，占内存越少

- 排序（算法）sorting：数组array

选择排序selection sort：在一组数中扫描找到最小的，放在最上面，再循环找到第二小的，再……O（n^2)

- 算法的输入大小和运行步骤的关系是算法的 复杂度O，表示运行速度的量级

- 归并排序merge sort，数字分组，两组之间排序（第一次每个数字一组）O(n*log N)    n:比较+合并 的次数；log N：合并步骤的次数

- 蛮力方法：一个个算出来比较：O（n!)      n*(n-1) *(n-2) *,,,,,,,, *1
-  图搜索问题：比如算路线

dijkstra算法 O（n long n +i)。  n节点数,i多少条线：每次从最近的节点出发，把每个相邻的节点都走一遍，进行统计

如果两步a-->b  >  a--->b---->c，就放弃abc路径

## 14数据结构

![image-20210704172458125](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704172458125.png)

- 数据结构data structures：整理算法处理数据，使其有结构化，方便使用

- 数组arry/列表list/向量vector ：数组的值连续地存在内存里，从上往下储存（比如地址1000～1200）

下标index：为了拿出数组的某个值

- 字符串string：文字，数字，标点等等 组成的数组，数组的每个元素都是一个字符

字符串在内存里以0结尾（二进制null），表示字符串的结尾 

处理字符串的函数：连接字符串的函数stract

- 二维数组：矩阵matrix：数组里的每个元素都是一个数组

![image-20210704174205540](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704174205540.png)

![image-20210704174222457](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704174222457.png)

- 多个变量打包在一起是结构体struct

- 数组创建时就有固定大小，在内存中按顺序储存，两者后面都最好不修改

- 一个结构体:节点node：存一个指针pointer

用节点做链表linked list：链表是一种灵活的数据结构，可以存很多个节点

灵活性通过每个节点指向下一个节点实现

循环链表：一个节点的值多少，指向一个地址，这个地址是另外的节点，读出节点的值，如此循环，最后一个节点的地址指向第一个节点

非循环：最后的指针是0（null)

链表大小可以动态增减，方便排序

- 运用链表的数据结构：队列queue,栈stack

队列（谁先来谁在前面 先进先出first-in first-out,FIFO)

栈（后进先出LIFO吃松饼） ：入栈push，出栈pop

- 一个节点带多个个指针：树

最高的节点：根节点root

除了根节点之外的都是字节点children

字节点点直属上层是母节点：parent node

最后树结束的地方：叶节点leaf nodes

- 最多只有两个节点的是 二叉树 binary tree

- 根叶单向

## 15阿兰 图灵

![image-20210704180513607](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704180513607.png)

阿兰 图灵Alan Turing

- 可判定性问题：decision problem：一种算法，输入正式逻辑语句输出准确是或否答案

图灵机：纸带

图灵完备turing complete

- 停机问题：什么时候停止计算，如何：通过两个图灵机的悖论说明不能做到

计算机有极限：可计算性理论，丘奇-图灵论题

解决加密encryption

- 人工智能artificial intelligence

如果计算机能欺骗人类相信它是人类，才算智能：图灵测试（智能测试的基础）

=公开全自动图灵测试（验证码）：区分人与电脑 

- 图灵奖：计算机的诺贝尔奖

## 16软件工程

![image-20210704203745821](%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE.assets/image-20210704203745821.png)

- 软件工程software engineering

- 代码太多怎么办：把函数打包成层级，相关代码放在一起：打包成对象objects

把函数打包成对象的思想：面向对象编程objected programming，有面向对象编程语言

可以层层打包：对象可以包含其他对象

- 每个团队负责编程的不同部分：其他团队需要文档，帮助理解代码都做什么，以及定义好的“程序编程接口”application programming interface API（不需要知道具体细节，会用就行）

API控制哪些函数数据可以外部访问，哪些不能

- 面向对象编程的核心：隐藏复杂度，选择性的公布功能

- 集成开发环境IDE integrated development environments写代码，编译，测试等等的集合体

- 调试debug：程序崩了，定位出错代码，根据提供的信息，解决问题

VIM（推荐使用）

- 给代码

写文档：readme

文档提升复用性，直接用别人写好的，减少重复劳动

- 注释很重要

- 源代码管理sorce control /版本控制：可以跟着所以变化

大型软件公司会把代码放在一个中心服务器上：代码仓库code repository，想改代码时可以check out在IDE，修改完了提交commit

代码的主版本master

- 测试代码：质量保证测试quality assurance QA ，找bug 

- beta版软件：接近完成，没有完全测试通过，有的公司会公布

alpa版本：内部测试

